using UnityEngine;

using System.Collections;
using System;
using System.Collections.Generic;
[AddComponentMenu("QuickPath/Grid")]
[ExecuteInEditMode]
/// <summary>
/// Creates a grid for MoveObjects to move around on.
/// </summary>
public class qpGrid : MonoBehaviour
{
    /// <summary>
    /// Grid map of all nodes generated. Used for finding and setting node connections.
    /// </summary>
    public qpNode[, ,] gridNodes;

    public List<qpNode> allNodes = new List<qpNode>();  // List containing all nodes generated by this grid.

    public Vector3 startCoordinates = new Vector3(-50, -50, -50);      // Start position from which to ray cast for terrain suitable for nodes.
    public Vector3 endCoordinates = new Vector3(50, 50, 50);          // End position from which to ray cast for terrain suitable for nodes.

    public List<string> DisallowedTags = new List<string>();    // List of tags that when raycasted against will not create node.
    public List<string> IgnoreTags = new List<string>();        //? List of tags that when raycasted against will not create node.

    public bool DrawInEditor = true;    // Draws a line at each node, and draws a line between each connection between two nodes. Helpful when baking grids.

    public enum Axis {Y=4}; //The Axises

    public Axis  UpDirection = Axis.Y;   //The designated updirection.
    public float UpRaycastStart = 12;   // Indicates where the raycasting for generating nodes should start on the updirection axis.
    public float UpRayCastEnd = -12;    // Indicates where the raycasting for generating nodes should end on the updirection axis.

    public float step = 1;    // Indicates the distance between each node.

    private List<Vector3> _lineRayStarts = new List<Vector3>();
    private List<Vector3> _lineRayEnds = new List<Vector3>();
    private qpManager _manager;
    
    private List<GameObject> _invisibleGrid = new List<GameObject>();
    
    public void Awake () {
        //Generate new nodes with raycast collision detection
        Debug.Log("all nodes:" + allNodes.Count);
        qpManager.Instance.RegisterNodes(allNodes);
        Debug.Log("qpmanager instance nodes:" + qpManager.Instance.nodes.Count);

        if (startCoordinates == Vector3.zero && endCoordinates == Vector3.zero && renderer != null) {
            float width = renderer.bounds.size.x / 50;
            float length = renderer.bounds.size.z / 50;
            float height = renderer.bounds.size.y / 50;
            startCoordinates = new Vector3(this.transform.position.x - (width * .5f), this.transform.position.y - (height * .5f), this.transform.position.z - (length * .5f));
            endCoordinates = new Vector3(startCoordinates.x + width, startCoordinates.y + height, startCoordinates.z + length);
        }
        Debug.Log("generate nodes from:" + startCoordinates + " to " + endCoordinates);
        
        _generateGrid();

        int connections = 0;
        foreach (qpNode node in allNodes) {
            connections += node.ContactedNodes.Count;
        }
        Debug.Log("found " + connections + " node connections");
        Debug.Log("found " + allNodes.Count + " nodes.");
    }

    public void Bake()  // Deletes nodes and rebuilds the entire grid.
    {
        _manager = qpManager.Instance;
        _manager.DelistNodes(allNodes);
        allNodes = new List<qpNode>();
        _generateGrid();
        DontDestroyOnLoad(_manager);
        //Debug.Log("nodes:" + allNodes.Count+" disallowed tags:"+DisallowedTags.Count+"DisallowedTag:"+DisallowedTags[2]);
    }

    public void Update()
    {
        if (DrawInEditor) {
            for (int i = _lineRayStarts.Count; i > 0; i--) {
                Debug.DrawLine(_lineRayStarts[i - 1], _lineRayEnds[i - 1],Color.blue,0,true);
            }

            foreach (qpNode node in allNodes) {
                foreach (qpNode neighbour in node.ContactedNodes) {
                    Debug.DrawLine(node.GetCoordinates(), neighbour.GetCoordinates(), new Color(0,0,1,.7f), 0, true);
                }
            }
        }
    }

    private bool _nodeCanBePlaced(out Vector3 point, Ray ray)
    {
        point = Vector3.zero;
        RaycastHit[] hits = Physics.RaycastAll(ray, 100.0F);
        
        bool placeNode = (hits.Length != 0) ? true : false;

        int countIgnoreHits = 0;
        int hitCounter = 0;

        while (hitCounter < hits.Length) {
            RaycastHit hit = hits[hitCounter];
            if (DisallowedTags.Contains(hit.collider.gameObject.tag)) {
                placeNode = false;
            } else if (IgnoreTags.Contains(hit.collider.gameObject.tag)) {
                countIgnoreHits++;
            } else {
                point = hit.point;
            }
            hitCounter++;
        }

        placeNode = (hitCounter == countIgnoreHits) ? false : placeNode;

        return (placeNode);
    }

    /*private void _createInvisibleGrid()
    {
        DisallowedTags.Add ("Obstacles");
        GameObject respawn = GameObject.FindWithTag("grid");
        respawn.transform = new Vector3 (startCoordinates.x - 1, startCoordinates.y - 1, startCoordinates.z - 1);

        GameObject nodeForRaycast = Instantiate(respawn) as GameObject;
        
    }*/


    private void _generateGrid()
    {
        _lineRayEnds = new List<Vector3>();
        _lineRayStarts = new List<Vector3>();

        Vector3 size = new Vector3(Mathf.Abs(startCoordinates.x - endCoordinates.x), Mathf.Abs(startCoordinates.y - endCoordinates.y), Mathf.Abs(startCoordinates.z - endCoordinates.z));

         int numOfNodesInX = (int)(size.x / step);
         int numOfNodesInY = (int)(size.y / step);
         int numOfNodesInZ = (int)(size.z / step);

        gridNodes = new qpNode[numOfNodesInX + 2, numOfNodesInY + 2, numOfNodesInZ + 2];

        int numOfNodesInXZLayer = numOfNodesInX * numOfNodesInZ;

        for (int y = 0; y < numOfNodesInY; y++) {
            for (int z = 0; z < numOfNodesInZ; z++) {
                for (int x = 0; x < numOfNodesInX; x++) {

                    Vector3 rayCastPositionStart = Vector3.zero;
                    Vector3 rayDirection = Vector3.zero;
                    
                    float coordX = startCoordinates.x + x;
                    float coordY = startCoordinates.y + y;
                    float coordZ = startCoordinates.z + z;

                    if (UpDirection == Axis.Y) {
                        rayCastPositionStart = new Vector3(coordX, UpRaycastStart, coordZ);
                        rayDirection = new Vector3(0, -1f);
                    }

                    Vector3 point = new Vector3(coordX, coordY, coordZ);
                    qpGridNode gridNode = null;

                    LayerMask layerMask = -1; //LayerMask.NameToLayer("Obstacles");
                    bool nodeCanBePlaced = !Physics.CheckSphere(point, step/*1.4142f*/, layerMask); // check point with raycast distance to the closest objects with 'obstacle' tag

                    //bool nodeCanBePlaced = true;

                    if (nodeCanBePlaced) {
                        gridNode = new qpGridNode(point);
                        gridNodes[x, y, z] = gridNode;
                        allNodes.Add(gridNode);

                        if (UpDirection == Axis.Y) {
                            rayCastPositionStart.y = point.y + 1;
                        }

                        if (point != Vector3.zero) {
                            _lineRayEnds.Add(point);
                            _lineRayStarts.Add(rayCastPositionStart);
                        }
                    }

                    if (gridNode != null) {  //Set connection for grid node
                        if ((x - 1) >= 0) {
                            if (gridNodes[x - 1, y, z] != null) {
                                gridNode.SetMutualConnection(gridNodes[x - 1, y, z]);
                            }

                            if (y > 0) {
                                if (gridNodes[x - 1, y - 1, z] != null) {
                                    gridNode.SetMutualConnection(gridNodes[x - 1, y - 1, z], true);
                                }

                                if (gridNodes[x - 1, y - 1, z + 1] != null) {
                                    gridNode.SetMutualConnection(gridNodes[x - 1, y - 1, z + 1]);
                                }
                            }

                            if ((z - 1) >= 0) {
                                if (gridNodes[x - 1, y, z - 1] != null) {
                                    gridNode.SetMutualConnection(gridNodes[x - 1, y, z - 1], true);
                                }

                                if ((y > 0) && (gridNodes[x - 1, y - 1, z - 1] != null)) {
                                    gridNode.SetMutualConnection(gridNodes[x - 1, y - 1, z - 1], true);
                                }
                            }
                        }

                        if ((z - 1) >= 0) {
                            if (gridNodes[x, y, z - 1] != null) {
                                gridNode.SetMutualConnection(gridNodes[x, y, z - 1]);
                            }

                            if ((y > 0) && (gridNodes[x, y - 1, z - 1] != null)) {
                                gridNode.SetMutualConnection(gridNodes[x, y - 1, z - 1], true);
                            }

                            if (gridNodes[x + 1, y, z - 1] != null) {
                                gridNode.SetMutualConnection(gridNodes[x + 1, y, z - 1], true);
                            }

                            if ((y > 0) && (gridNodes[x + 1, y, z - 1] != null)) {
                                gridNode.SetMutualConnection(gridNodes[x + 1, y - 1, z - 1], true);
                            }
                        }

                        if (y > 0) {
                            if (gridNodes[x, y - 1, z] != null) {
                                gridNode.SetMutualConnection(gridNodes[x, y - 1, z]);
                            }

                            if (gridNodes[x + 1, y - 1, z] != null) {
                                gridNode.SetMutualConnection(gridNodes[x + 1, y - 1, z]);
                            }

                            if (gridNodes[x, y - 1, z + 1] != null) {
                                gridNode.SetMutualConnection(gridNodes[x, y - 1, z + 1]);
                            }

                            if (gridNodes[x + 1, y - 1, z + 1] != null) {
                                gridNode.SetMutualConnection(gridNodes[x + 1, y - 1, z + 1]);
                            }
                        }
                    }
                }
            }

        }
        qpManager.Instance.RegisterNodes(allNodes);
    }

    //void OnDisable()
    //{
    //    Debug.Log("instance:" + qpManager.Instance);
    //    Debug.Log("nodes:" + allNodes);
    //    qpManager.Instance.DelistNodes(allNodes);
    //}
    //void OnDestroy()
    //{
    //    qpManager.Instance.DelistNodes(allNodes);
    //}
}