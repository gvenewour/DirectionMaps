using UnityEngine;

using System.Collections;
using System;
using System.Collections.Generic;
[AddComponentMenu("QuickPath/Grid")]
[ExecuteInEditMode]
/// <summary>
/// Creates a grid for MoveObjects to move around on.
/// </summary>
public class qpGrid : MonoBehaviour
{
    /// <summary>
    /// Grid map of all nodes generated. Used for finding and setting node connections.
    /// </summary>
    public qpNode[, ,] gridNodes;

    public List<qpNode> allNodes = new List<qpNode>();  // List containing all nodes generated by this grid.

    public Vector3 startCoordinates = new Vector3(-50, -50, -50);      // Start position from which to ray cast for terrain suitable for nodes.
    public Vector3 endCoordinates = new Vector3(50, 50, 50);          // End position from which to ray cast for terrain suitable for nodes.

    public List<string> DisallowedTags = new List<string>();    // List of tags that when raycasted against will not create node.
    public List<string> IgnoreTags = new List<string>();        //? List of tags that when raycasted against will not create node.

    public bool DrawInEditor = true;    // Draws a line at each node, and draws a line between each connection between two nodes. Helpful when baking grids.

    public enum Axis {Y=4}; //The Axises

    public Axis  UpDirection = Axis.Y;   //The designated updirection.
    public float UpRaycastStart = 12;   // Indicates where the raycasting for generating nodes should start on the updirection axis.
    public float UpRayCastEnd = -12;    // Indicates where the raycasting for generating nodes should end on the updirection axis.

    public float step = 1;    // Indicates the distance between each node.

    private List<Vector3> _lineRayStarts = new List<Vector3>();
    private List<Vector3> _lineRayEnds = new List<Vector3>();
    private qpManager _manager;

    private List<GameObject> invisibleGrid;

    public void Awake () {
        //Generate new nodes with raycast collision detection
        Debug.Log("all nodes:" + allNodes.Count);
        qpManager.Instance.RegisterNodes(allNodes);
        Debug.Log("qpmanager instance nodes:" + qpManager.Instance.nodes.Count);

        if (startCoordinates == Vector3.zero && endCoordinates == Vector3.zero && renderer != null) {
            float width = renderer.bounds.size.x / 50;
            float length = renderer.bounds.size.z / 50;
            float height = renderer.bounds.size.y / 50;
            startCoordinates = new Vector3(this.transform.position.x - (width * .5f), this.transform.position.y - (height * .5f), this.transform.position.z - (length * .5f));
            endCoordinates = new Vector3(startCoordinates.x + width, startCoordinates.y + height, startCoordinates.z + length);
        }
        Debug.Log("generate nodes from:" + startCoordinates + " to " + endCoordinates);
        
        _generateGrid();

        int connections = 0;
        foreach (qpNode node in allNodes) {
            connections += node.ContactedNodes.Count;
        }
        Debug.Log("found " + connections + " node connections");
        Debug.Log("found " + allNodes.Count + " nodes.");
    }

    public void Bake()  // Deletes nodes and rebuilds the entire grid.
    {
        _manager = qpManager.Instance;
        _manager.DelistNodes(allNodes);
        allNodes = new List<qpNode>();
        _generateGrid();
        DontDestroyOnLoad(_manager);
        //Debug.Log("nodes:" + allNodes.Count+" disallowed tags:"+DisallowedTags.Count+"DisallowedTag:"+DisallowedTags[2]);
    }

    public void Update()
    {
        if (DrawInEditor) {
            for (int i = _lineRayStarts.Count; i > 0; i--) {
                Debug.DrawLine(_lineRayStarts[i - 1], _lineRayEnds[i - 1],Color.blue,0,true);
            }

            foreach (qpNode node in allNodes) {
                foreach (qpNode neighbour in node.ContactedNodes) {
                    Debug.DrawLine(node.GetCoordinates(), neighbour.GetCoordinates(), new Color(0,0,1,.7f), 0, true);
                }
            }
        }
    }

    private bool _nodeCanBePlaced(out Vector3 point, Ray ray)
    {
        point = Vector3.zero;
        RaycastHit[] hits = Physics.RaycastAll(ray, 100.0F);
        
        bool placeNode = (hits.Length != 0) ? true : false;

        int countIgnoreHits = 0;
        int hitCounter = 0;

        while (hitCounter < hits.Length) {
            RaycastHit hit = hits[hitCounter];
            if (DisallowedTags.Contains(hit.collider.gameObject.tag)) {
                placeNode = false;
            } else if (IgnoreTags.Contains(hit.collider.gameObject.tag)) {
                countIgnoreHits++;
            } else {
                point = hit.point;
            }
            hitCounter++;
        }

        placeNode = (hitCounter == countIgnoreHits) ? false : placeNode;

        return (placeNode);
    }

    private void _generateGrid()
    {
        _lineRayEnds = new List<Vector3>();
        _lineRayStarts = new List<Vector3>();

        Vector3 size = new Vector3(Mathf.Abs(startCoordinates.x - endCoordinates.x), Mathf.Abs(startCoordinates.y - endCoordinates.y), Mathf.Abs(startCoordinates.z - endCoordinates.z));

        int numOfNodesInX = (int)(size.x / step);
        int numOfNodesInY = (int)(size.y / step);
        int numOfNodesInZ = (int)(size.z / step);

        gridNodes = new qpNode[numOfNodesInX + 2, numOfNodesInY + 2, numOfNodesInZ + 2];

        int numOfNodesInXZLayer = numOfNodesInX * numOfNodesInZ;

        for (int y = 0; y < numOfNodesInY; y++) {
            for (int nodeIndex = 0; nodeIndex < numOfNodesInXZLayer; nodeIndex++) {

                Vector3 rayCastPositionStart = Vector3.zero;
                Vector3 rayDirection = Vector3.zero;

                int row = (int)Mathf.Floor(nodeIndex * step / size.x);
                float x = ((nodeIndex * step) - (row * size.x)) + startCoordinates.x;
                float z = (row * step) + startCoordinates.z;

                if (UpDirection == Axis.Y) {
                    rayCastPositionStart = new Vector3(x, UpRaycastStart, z);
                    rayDirection = new Vector3(0, -1f);
                }

                Ray ray = new Ray(rayCastPositionStart, rayDirection);
                qpGridNode gridNode = null;
                Vector3 point = Vector3.zero;

                if (_nodeCanBePlaced(out point, ray)) {                        //Collision detected on floor
                    gridNode = new qpGridNode(point);
                    allNodes.Add(gridNode);

                    if (UpDirection == Axis.Y) {
                        rayCastPositionStart.y = point.y + 1;
                    }

                    if (point != Vector3.zero) {
                        _lineRayEnds.Add(point);
                        _lineRayStarts.Add(rayCastPositionStart);
                    }
                }

                int zindex = (int)Mathf.Floor(nodeIndex / (size.x / step));
                int xindex = (int)(nodeIndex - (Mathf.Ceil(zindex * (size.x / step))));
                //Debug.Log("i:" + i + " spread:" + spread + " dif.x:" + size.x + " dif.y:" + size.y + " row:" + row + " x:" + x + " z:" + z+" xindex:"+xindex+" zindex:"+zindex);

                gridNodes[xindex, y, zindex] = gridNode;

                if (gridNode != null) {  //Set connection for grid node
                    if ((xindex - 1) > 0) {
                        if (gridNodes[xindex - 1, y, zindex] != null) {
                            gridNode.SetMutualConnection(gridNodes[xindex - 1, y, zindex]);
                        }

                        if (y > 0) {
                            if (gridNodes[xindex - 1, y - 1, zindex] != null) {
                                gridNode.SetMutualConnection(gridNodes[xindex - 1, y - 1, zindex], true);
                            }

                            if (gridNodes[xindex - 1, y - 1, zindex + 1] != null) {
                                gridNode.SetMutualConnection(gridNodes[xindex - 1, y - 1, zindex + 1]);
                            }

                        }

                        if ((zindex - 1) > 0) {
                            if (gridNodes[xindex - 1, y, zindex - 1] != null) {
                                gridNode.SetMutualConnection(gridNodes[xindex - 1, y, zindex - 1], true);
                            }

                            if ((y > 0) && (gridNodes[xindex - 1, y - 1, zindex - 1] != null)) {
                                gridNode.SetMutualConnection(gridNodes[xindex - 1, y - 1, zindex - 1], true);
                            }
                        }
                    }

                    if ((zindex - 1) > 0) {
                        if (gridNodes[xindex, y, zindex - 1] != null) {
                            gridNode.SetMutualConnection(gridNodes[xindex, y, zindex - 1]);
                        }

                        if ((y > 0) && (gridNodes[xindex, y - 1, zindex - 1] != null)) {
                            gridNode.SetMutualConnection(gridNodes[xindex, y - 1, zindex - 1], true);
                        }

                        if (gridNodes[xindex + 1, y, zindex - 1] != null) {
                            gridNode.SetMutualConnection(gridNodes[xindex + 1, y, zindex - 1], true);
                        }

                        if ((y > 0) && (gridNodes[xindex + 1, y, zindex - 1] != null)) {
                            gridNode.SetMutualConnection(gridNodes[xindex + 1, y - 1, zindex - 1], true);
                        }
                    }

                    if (y > 0) {
                        if (gridNodes[xindex, y - 1, zindex] != null) {
                            gridNode.SetMutualConnection(gridNodes[xindex, y - 1, zindex]);
                        }

                        if (gridNodes[xindex + 1, y - 1, zindex] != null) {
                            gridNode.SetMutualConnection(gridNodes[xindex + 1, y - 1, zindex]);
                        }

                        if (gridNodes[xindex, y - 1, zindex + 1] != null) {
                            gridNode.SetMutualConnection(gridNodes[xindex, y - 1, zindex + 1]);
                        }

                        if (gridNodes[xindex + 1, y - 1, zindex + 1] != null) {
                            gridNode.SetMutualConnection(gridNodes[xindex + 1, y - 1, zindex + 1]);
                        }
                    }


                }

            }
        }

        qpManager.Instance.RegisterNodes(allNodes);
    }

    //void OnDisable()
    //{
    //    Debug.Log("instance:" + qpManager.Instance);
    //    Debug.Log("nodes:" + allNodes);
    //    qpManager.Instance.DelistNodes(allNodes);
    //}
    //void OnDestroy()
    //{
    //    qpManager.Instance.DelistNodes(allNodes);
    //}
}